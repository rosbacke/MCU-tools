It should  be possible to define the FSM tree statically
by declaring substates as template arguments.

Initial idea is to have a separate structure doing this.

Assume a class FsmNode

class S1; 
class S2;
class S3;
class S4;

using Base1 = FsmNode<S3, S1, S2>;  // First base class with S1, S2 as subclasses.
using Root = FsmNode<S4, Base1, S4>;  

Root node describing the entire FSM, where S3 & S4 are on the same level and S1, S2
are substates to S3.

A crucial step is to transform this tree of states into a linear array representation.
This correspond to a depth first search of the tree and laying out the nodes linerarly after
this order. 
Main reason for this sorting is that all substates (recursively) will be stored before the 
next sibling state appears. This allow us to define a property 'area'.
- Leaf states have an area of 1.
- Base states have an area of 1 + sum of areas for the nearest substates of the base state.
Having area and a backlink index from subnodes to their base node allow efficient traversal
from substates up toward the root, and to sibling states.

Needed output from this array include the following:
- Total storage size of the static array.
- The maximum depth in any part of the tree.
- A way to traverse from a specific node to root effectively.

Additional data of interest, but not yet solved:
- For a given level, determine the largest state class to get needed memory.
- Given some identifier of a state, find the right index into the array.

Outstanding questions: What kind of identifier should we use?
- Currently using external enum. It is a target for 'transition' calls.

Do note that this opens up the possibility to use the same class for
several states. To effectively use this we need to pass different 
constructor arguments to the different states.

Main use is for the 'transition'. To jump within the state machine upon events.
Also: Identify init state.

Giving some custom type to each state. This is more general than the enum.


Assume we are using the enum variant.
- User supplies enum type.
- In each declaration of state hierarchy, supply an enum value, so it is part 
  of the tree hierarchy.
- When doing a transition we should be able to derive the direct id at compile time.
- For runtime support, will probably a table. Or runtime search or maybe compile
  time translation and then storage of indexes in an opaque type.



State class interface:
- Currently using 'fsmBase' pointer passed through to base class. It allows
  the base class to offer access to 'transition', 'fsm class' etc.

- Would be good to have another way to pass this point in. Would free up
  constructors for user supplied data.

Alternative:
- Duck typing an interface. Assuming the state function has a 'set' function to be 
  called upon construction.
- Downside: Can't access this data during object construction.
  - Alternative: Have some method f√∂r the user maker function to access this,
    then the user can opt in to pass it ito the state constructor.

- Already got the event requirement. Another function for setting the fsm is 
  straight forward. Can pass the state id this way also.
- Maker function needed to build the class. Runtime setting of stateId. Can make
  it statically via template class. It means specifying template argument when
  setting up FSM structure.

- Need to supply a Maker function. The default maker default construct the class
  in place. (Note on alignment. C++17 got __STDCPP_DEFAULT_NEW_ALIGNMENT__.
  It is the default alignment from system new operator. test show '16' for linux)
- Give make function as 3:rd (template) argument. 
- The make function must follow some protocol to allow picking up pointer to memory
  and 
  

Can be done by these stages:
A struct Wrap that handle the diffence between class S(x) and Base1 as arguments above.
A struct FsmArea used to calculate the area of a base-state and all it's substates recursively.
A template function 'get' that gets the offset 

